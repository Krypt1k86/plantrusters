webpackHotUpdate("static/development/pages/holders.js",{

/***/ "./components/Layout.tsx":
/*!*******************************!*\
  !*** ./components/Layout.tsx ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! styled-jsx/style */ "./node_modules/styled-jsx/style.js");
/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(styled_jsx_style__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Navigation */ "./components/Navigation.tsx");
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/head */ "./node_modules/next/dist/next-server/lib/head.js");
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react_retina_image__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-retina-image */ "./node_modules/react-retina-image/dist/index.js");
/* harmony import */ var react_retina_image__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_retina_image__WEBPACK_IMPORTED_MODULE_4__);
var _jsxFileName = "/Users/davidhovey/SaintFame/saintfame/components/Layout.tsx";

var __jsx = react__WEBPACK_IMPORTED_MODULE_1__["createElement"];





var Layout = function Layout(_ref) {
  var children = _ref.children,
      title = _ref.title;
  return __jsx("div", {
    className: "jsx-1333191592",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 11
    },
    __self: this
  }, __jsx("link", {
    rel: "stylesheet",
    type: "text/css",
    href: "//fonts.googleapis.com/css?family=Tenor+Sans",
    className: "jsx-1333191592",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 12
    },
    __self: this
  }), __jsx(next_head__WEBPACK_IMPORTED_MODULE_3___default.a, {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 17
    },
    __self: this
  }, __jsx("title", {
    className: "jsx-1333191592",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 18
    },
    __self: this
  }, "SAINT FAME"), __jsx("meta", {
    name: "viewport",
    content: "initial-scale=1.0, width=device-width",
    className: "jsx-1333191592",
    __source: {
      fileName: _jsxFileName,
      lineNumber: 19
    },
    __self: this
  })), __jsx(_Navigation__WEBPACK_IMPORTED_MODULE_2__["default"], {
    __source: {
      fileName: _jsxFileName,
      lineNumber: 24
    },
    __self: this
  }), __jsx(react_retina_image__WEBPACK_IMPORTED_MODULE_4___default.a, {
    src: __webpack_require__(/*! ./logo.png */ "./components/logo.png"),
    __source: {
      fileName: _jsxFileName,
      lineNumber: 25
    },
    __self: this
  }), children, __jsx(styled_jsx_style__WEBPACK_IMPORTED_MODULE_0___default.a, {
    id: "1333191592",
    __self: this
  }, "body{background:black;color:#fff;}a{font-family:Tenor Sans;font-style:normal;font-weight:normal;font-size:25px;line-height:40px;color:#fffafa;}h1{color:#fff;}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXZpZGhvdmV5L1NhaW50RmFtZS9zYWludGZhbWUvY29tcG9uZW50cy9MYXlvdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTBCMkIsQUFHa0MsQUFJTSxBQVNaLFdBQ2YsTUFiZSxNQUlPLEtBSHRCLGFBSXVCLG1CQUNKLGVBQ0UsaUJBRUgsY0FDbEIiLCJmaWxlIjoiL1VzZXJzL2RhdmlkaG92ZXkvU2FpbnRGYW1lL3NhaW50ZmFtZS9jb21wb25lbnRzL0xheW91dC50c3giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBOYXZpZ2F0aW9uIGZyb20gJy4vTmF2aWdhdGlvbidcbmltcG9ydCBIZWFkIGZyb20gJ25leHQvaGVhZCdcbmltcG9ydCBSZXRpbmFJbWFnZSBmcm9tICdyZWFjdC1yZXRpbmEtaW1hZ2UnXG5cbnR5cGUgTGF5b3V0UHJvcHMgPSB7XG4gICAgdGl0bGU/OiBzdHJpbmdcbn1cblxuY29uc3QgTGF5b3V0OiBSZWFjdC5GdW5jdGlvbkNvbXBvbmVudDxMYXlvdXRQcm9wcz4gPSAoeyBjaGlsZHJlbiwgdGl0bGUgfSkgPT4gKFxuICAgIDxkaXY+XG4gICAgICAgIDxsaW5rXG4gICAgICAgICAgICByZWw9XCJzdHlsZXNoZWV0XCJcbiAgICAgICAgICAgIHR5cGU9XCJ0ZXh0L2Nzc1wiXG4gICAgICAgICAgICBocmVmPVwiLy9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PVRlbm9yK1NhbnNcIlxuICAgICAgICAvPlxuICAgICAgICA8SGVhZD5cbiAgICAgICAgICAgIDx0aXRsZT5TQUlOVCBGQU1FPC90aXRsZT5cbiAgICAgICAgICAgIDxtZXRhXG4gICAgICAgICAgICAgICAgbmFtZT1cInZpZXdwb3J0XCJcbiAgICAgICAgICAgICAgICBjb250ZW50PVwiaW5pdGlhbC1zY2FsZT0xLjAsIHdpZHRoPWRldmljZS13aWR0aFwiXG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0hlYWQ+XG4gICAgICAgIDxOYXZpZ2F0aW9uIC8+XG4gICAgICAgIDxSZXRpbmFJbWFnZSBzcmM9e3JlcXVpcmUoJy4vbG9nby5wbmcnKX0gLz5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8c3R5bGUgZ2xvYmFsIGpzeD57YFxuICAgICAgICAgICAgYm9keSB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogYmxhY2s7XG4gICAgICAgICAgICAgICAgY29sb3I6ICNmZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhIHtcbiAgICAgICAgICAgICAgICBmb250LWZhbWlseTogVGVub3IgU2FucztcbiAgICAgICAgICAgICAgICBmb250LXN0eWxlOiBub3JtYWw7XG4gICAgICAgICAgICAgICAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcbiAgICAgICAgICAgICAgICBmb250LXNpemU6IDI1cHg7XG4gICAgICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDQwcHg7XG5cbiAgICAgICAgICAgICAgICBjb2xvcjogI2ZmZmFmYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGgxIHtcbiAgICAgICAgICAgICAgICBjb2xvcjogI2ZmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYH08L3N0eWxlPlxuICAgIDwvZGl2PlxuKVxuZXhwb3J0IGRlZmF1bHQgTGF5b3V0XG4iXX0= */\n/*@ sourceURL=/Users/davidhovey/SaintFame/saintfame/components/Layout.tsx */"));
};

/* harmony default export */ __webpack_exports__["default"] = (Layout);

/***/ }),

/***/ "./node_modules/array-equal/index.js":
/*!*******************************************!*\
  !*** ./node_modules/array-equal/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {


module.exports = function equal(arr1, arr2) {
  var length = arr1.length
  if (length !== arr2.length) return false
  for (var i = 0; i < length; i++)
    if (arr1[i] !== arr2[i])
      return false
  return true
}


/***/ }),

/***/ "./node_modules/image-exists/index.js":
/*!********************************************!*\
  !*** ./node_modules/image-exists/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var checks = {};

module.exports = function(src, callback) {
  if (src in checks) {
    return callback(checks[src]);
  }

  var img = new Image();

  img.onload = function() {
    checks[src] = true;
    callback(true);
  };

  img.onerror = function() {
    checks[src] = false;
    callback(false);
  };

  img.src = src;
};


/***/ }),

/***/ "./node_modules/is-retina/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-retina/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function() {
  var mediaQuery;
  if (typeof window !== "undefined" && window !== null) {
    mediaQuery = "(-webkit-min-device-pixel-ratio: 1.25), (min--moz-device-pixel-ratio: 1.25), (-o-min-device-pixel-ratio: 5/4), (min-resolution: 1.25dppx)";
    if (window.devicePixelRatio > 1.25) {
      return true;
    }
    if (window.matchMedia && window.matchMedia(mediaQuery).matches) {
      return true;
    }
  }
  return false;
};


/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/react-retina-image/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-retina-image/dist/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.5
var PropTypes, React, RetinaImage, arrayEqual, assign, imageExists, isRetina, path,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = __webpack_require__(/*! react */ "./node_modules/react/index.js");

PropTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

isRetina = __webpack_require__(/*! is-retina */ "./node_modules/is-retina/index.js");

imageExists = __webpack_require__(/*! image-exists */ "./node_modules/image-exists/index.js");

path = __webpack_require__(/*! path */ "./node_modules/path-browserify/index.js");

assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

arrayEqual = __webpack_require__(/*! array-equal */ "./node_modules/array-equal/index.js");

module.exports = RetinaImage = (function(superClass) {
  extend(RetinaImage, superClass);

  RetinaImage.propTypes = {
    src: PropTypes.oneOfType([PropTypes.string, PropTypes.array]).isRequired,
    checkIfRetinaImgExists: PropTypes.bool,
    forceOriginalDimensions: PropTypes.bool,
    retinaImageSuffix: PropTypes.string,
    handleOnLoad: PropTypes.func,
    onLoad: PropTypes.func,
    onError: PropTypes.func
  };

  RetinaImage.defaultProps = {
    checkIfRetinaImgExists: true,
    forceOriginalDimensions: true,
    retinaImageSuffix: '@2x',
    onError: function() {}
  };

  function RetinaImage(props) {
    this.handleOnLoad = bind(this.handleOnLoad, this);
    RetinaImage.__super__.constructor.call(this, props);
    this.state = this.wrangleProps();
  }

  RetinaImage.prototype.componentWillReceiveProps = function(nextProps) {
    var isEqual;
    isEqual = true;
    if (Array.isArray(this.props.src) && Array.isArray(nextProps.src)) {
      isEqual = arrayEqual(this.props.src, nextProps.src);
    } else {
      isEqual = this.props.src === nextProps.src;
    }
    if (!isEqual) {
      return this.setState(assign(this.wrangleProps(nextProps), {
        width: null,
        height: null,
        imgLoaded: null,
        retinaImgExists: null,
        retinaCheckComplete: null
      }));
    }
  };

  RetinaImage.prototype.componentDidMount = function() {
    this.checkForRetina();
    return this.checkLoaded();
  };

  RetinaImage.prototype.componentDidUpdate = function() {
    return this.checkForRetina();
  };

  RetinaImage.prototype.render = function() {
    var imgProps;
    imgProps = assign({}, this.props);
    delete imgProps.src;
    delete imgProps.checkIfRetinaImgExists;
    delete imgProps.forceOriginalDimensions;
    delete imgProps.retinaImageSuffix;
    delete imgProps.handleOnLoad;
    delete imgProps.onLoad;
    delete imgProps.onError;
    imgProps.src = this.state.src;
    imgProps.onLoad = this.handleOnLoad;
    imgProps.onError = this.props.onError;
    if (this.state.width >= 0) {
      imgProps.width = this.state.width;
    }
    if (this.state.height >= 0) {
      imgProps.height = this.state.height;
    }
    return React.createElement("img", Object.assign({}, imgProps, {
      "ref": "img"
    }));
  };

  RetinaImage.prototype.wrangleProps = function(props) {
    if (props == null) {
      props = this.props;
    }
    if (Array.isArray(props.src)) {
      return {
        src: props.src[0],
        srcIsArray: true
      };
    } else {
      return {
        src: props.src,
        srcIsArray: false
      };
    }
  };

  RetinaImage.prototype.checkForRetina = function() {
    if (this.state.retinaCheckComplete) {
      return;
    }
    if (isRetina() && this.props.checkIfRetinaImgExists) {
      return imageExists(this.getRetinaPath(), (function(_this) {
        return function(exists) {
          var ref;
          if (exists && ((ref = _this.state) != null ? ref.imgLoaded : void 0)) {
            _this.setState({
              src: _this.getRetinaPath()
            });
          } else if (exists) {
            _this.setState({
              retinaImgExists: true
            });
          }
          return _this.setState({
            retinaCheckComplete: true
          });
        };
      })(this));
    } else if (isRetina() && !this.props.checkIfRetinaImgExists) {
      this.setState({
        src: this.getRetinaPath()
      });
      return this.setState({
        retinaCheckComplete: true
      });
    }
  };

  RetinaImage.prototype.checkLoaded = function() {
    var el;
    el = this.refs.img;
    if (!el.complete) {
      return false;
    }
    if (el.naturalWidth === 0) {
      return false;
    }
    return this.handleOnLoad();
  };

  RetinaImage.prototype.handleOnLoad = function(e) {
    var ref;
    if (this.props.onLoad != null) {
      this.props.onLoad(e);
    }
    if (this.props.handleOnLoad != null) {
      this.props.handleOnLoad(e);
    }
    if (this.props.forceOriginalDimensions) {
      this.setState({
        width: this.refs.img.clientWidth,
        height: this.refs.img.clientHeight
      });
    }
    this.setState({
      imgLoaded: true
    });
    if (((ref = this.state) != null ? ref.retinaImgExists : void 0) || !this.props.checkIfRetinaImgExists) {
      return this.setState({
        src: this.getRetinaPath()
      });
    }
  };

  RetinaImage.prototype.getRetinaPath = function() {
    var basename, src;
    if (this.state.srcIsArray) {
      return this.props.src[1];
    } else {
      basename = path.basename(this.props.src, path.extname(this.props.src));
      basename = basename + this.props.retinaImageSuffix + path.extname(this.props.src);
      src = this.props.src.replace(path.basename(this.props.src), basename);
      return src;
    }
  };

  return RetinaImage;

})(React.Component);


/***/ })

})
//# sourceMappingURL=holders.js.dedfc1223549d8ace0ac.hot-update.js.map